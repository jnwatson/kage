"""  Generates function signatures from btftool.

Usage:
  siggen <filename>

where filename is the output of:
  bpftool -j btf dump file <targetvmlinux>

Generates a C header that contains an array of name, signature string tuples,
along with an enum definition of structs the generated strings refer to.

The above command outputs a json that contains a single key 'types' that
contains an array of objects that refer to one another by their 'id' property.
Objects with 'kind'== 'FUNC' are root of the function information.  Its
'type_id' property refers to another type with 'kind' == 'FUNC_PROTO'.

FUNC_PROTO objects contain a property 'ret_type_id' and array property 'params'
that contain the name and type information for the function's return value and
parameters, respectively.

E.g.
{
  "types": [
...
    {
      "id": 100797,
      "kind": "FUNC_PROTO",
      "name": "(anon)",
      "ret_type_id": 2167,
      "vlen": 1,
      "params": [
        {
          "name": "modname",
          "type_id": 6
        }
      ]
    },
    {
      "id": 100798,
      "kind": "FUNC",
      "name": "kage_create",
      "type_id": 100797,
      "linkage": "static"
    },

See https://www.kernel.org/doc/html/v6.7/bpf/btf.html for detailed info

"""
import sys
import json
from collections.abc import Sequence

voidt = {
    "id": 0,
    "kind": 'VOID',
}

class SigGen:
  def __init__(self, js):

    all_types = {}
    types = js['types']
    self.func_types = list()

    # Index all types by id
    for typ in types:
      all_types[typ['id']] = typ
      if typ['kind'] == 'FUNC':
        self.func_types.append(typ)

    # Add the special void type
    all_types[0] = voidt

    self.all_types = all_types
    self.objmap = {}  # name -> index
    self.objidx = 1

  def getobjindex(self, obj):
    assert obj['kind'] == 'STRUCT'
    name = obj['name']
    if name == '(anon)':
      name = f'anon_{obj["id"]}'
    idx = self.objmap.get(name)
    if idx is not None:
      return idx
    idx = self.objidx
    self.objidx += 1
    self.objmap[name] = idx
    return idx

  def emit_header(self):
    print('// Autogenerated by siggen.py\n')
    print('struct func_sig {\n\tconst char *func;\n\tconst char *sig;\n};')
    print('struct func_sig funcsigs[] = {')

  def emit_footer(self):
    print('};')

  def drill_typedefs(self, param):
    if param.get('kind') == 'PTR':
      return param
    tid = param.get('type_id')
    if tid is None:
      return param
    t = self.all_types[tid]
    if t['kind'] not in ('TYPEDEF', 'RESTRICT'):
      return t
    return self.drill_typedefs(self.all_types[t['type_id']])

  def process_func(self, func):
    sig = []
    print(f'\t{{"{func['name']}", "', end='')
    has_func_ptr = False
    proto = self.all_types[func['type_id']]
    rv = self.all_types[proto['ret_type_id']]
    params = proto['params']
    for param in [rv] + params:
      paramtype = self.drill_typedefs(param)
      match paramtype['kind']:
        case 'INT' | 'ENUM' | 'ENUM64':
          size = paramtype['size']
          encoding = paramtype['encoding']
          # As a hack, treat any u64 param after a func ptr as a pointer
          if (has_func_ptr and paramtype['kind'] == 'INT' and size == 8 and
              encoding == '(none)'):
            sig.append('P')
          else:
            sig.append(f'I{size}')
        case 'STRUCT':
          sig.append('S')
        case 'PTR':
          tid = paramtype['type_id']
          target = self.drill_typedefs(self.all_types[tid])
          match target['kind']:
            case 'STRUCT':
              sig.append(f'B{self.getobjindex(target)}')
            case 'FUNC_PROTO':
              has_func_ptr = True
              sig.append(f'F{len(target["params"])}')
            case _:
              sig.append('P')
        case 'VOID':
          if param.get('name') == '(anon)':
            sig.append('A')  # this function has varargs
          else:
            sig.append('V')  # this function returns void
        case 'CONST':
          sig.append('I8')
        case 'UNION':
          sig.append('U')
          size = paramtype['size']
          sig.append(f'I{size}')
        case _:
          raise Exception(f"Found param of unknown kind {paramtype} in {proto}")
    print(f"{''.join(sig)}\"}},")


  def emit_sigs(self):
    self.emit_header()

    for func in self.func_types:
      self.process_func(func)

    self.emit_footer()

  def emit_objs(self):
    prefix= 'KAGE_SI_'
    print('enum kage_struct_indices {')
    for name, idx in sorted(self.objmap.items(), key=lambda item: item[1]):
      print(f'\t{prefix}{name} = {idx},')
    print('};')



def main(argv: Sequence[str]) -> None:
  if len(argv) > 2:
    raise app.UsageError("Too many command-line arguments.")
  with open(argv[1], 'r') as fp:
    j = json.load(fp)

  sg = SigGen(j)
  sg.emit_sigs()
  print()
  sg.emit_objs()

if __name__ == "__main__":
  main(sys.argv)
